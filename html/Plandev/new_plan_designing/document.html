
综合描述:
	一个curd的应用,从前端到后端,都以数据的更新和删除为中心.因此很明显,这种应用的中心是数据模型.

设计规范:
	Model
		{
			__keys={}
		}
	View
		{
			
		}
	Control
		{
			getModel(view)
			feedView(model)
		}
		假设有两个相关的模型:
			Main{id,title,status}
			Detail{id,mainid(Foreign Key),content}
		模型和数据库操作:
			查询 : 1.采用联合查询, 即先将Main Detail进行基于Main的左连接(Left Join),然后形成查询对象
				  2.查询是面向模型的查询.即所有的参数都在特定的模型中给出.实现这一点的关键是将两个模型进行联合运算.
				  		Main Left Join Detail With Main.id=Detail.mainid. 结果
				  		{
				  			Main.id/Detail.mainid
				  			title
				  			status
				  			Detail.id
				  			content
				  		}
				  3.从模型中解析查询参数
				  	为了让模型具有表示多个参数的能力,可以通过条件来设定模型参数.
				  	比如,一个模型的键
				  		值是None,表示此项无限定条件.(即这个键没有出现在模型中)
				  		值是单独的值,取这个值
				  		值是集合,取这些值中的一个.(如果将这种查询模型展开,它们所得到的模型总数就是集合之间的笛卡尔乘积总数)
				  	X={ id=[1,2] ,content=["love","like"]}.
				  	 a).不过无论如何, 当限定了某个集合而且能够使用全等符时,使用in操作符.
				  	 	模式语法为 select * from t where id in (?,?,...)
				  	 b).使用like和其他操作符时,使用or条件操作符,并用括号包围
				  	 	select * from t where content like 
				  	 c).默认为integer使用in操作符,为字符串使用like操作符号.可以在查询外传递额外的操作符参数,指明某个列想要使用的操作符
				  	 	X.__operater__={content,'='}
				  4.查询返回的数据还是模型
				  5.不需要过多的编程转换
				  		a).模型中的键名被用作数据库中的列名,因此如果有冲突,使用表名指明.如2所示
				  6.模型可以展开,形成基本的模型,因此模型有两个分类(模式模型和基本模型);模型也可以形成查询串,用于定位.
				  	模型是因为赋值的不同才导致其类型不同,它们都共用同一套键.
				  	为了在模型中添加元信息而不影响其和数据库的联系,约定使用__开头的数据不会作为列插入,它们会被用于源信息解析
				  	实际上,我们可以看到,select,delete,update都需要查询模型来定位数据.
			更新:
				删除: 只接受模式模型的删除.
					根据模型的值进行条件构造.与查询模型的条件构造是一样的.
				插入: 只接受基本模型组的插入.
					直接将每个模型展开为多个基本模型,先生成
				  	
				  		
				  	
				  	
				  	
				  	